"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
require("module-alias/register");
const routing_controllers_1 = require("routing-controllers");
const typedi_1 = require("typedi");
const _entities_1 = require("@entities");
const dotenv_1 = require("dotenv");
const glob_1 = require("glob");
const path_1 = require("path");
const typeorm_1 = require("typeorm");
const jsonwebtoken_1 = require("jsonwebtoken");
const _entities_2 = require("@entities");
dotenv_1.config();
const { APP_PORT, EXT, JWT_SECRET, CONNECT_WITH_DB } = process.env;
const init = async () => {
    const getJWT = ({ authorization }) => {
        if (authorization) {
            const [, token] = authorization.split(' ');
            return token;
        }
        else {
            return null;
        }
    };
    const decodeJWT = (token) => jsonwebtoken_1.decode(token);
    const controllersPath = path_1.join(__dirname, `controllers/**/*.controller.${EXT}`);
    const controllersNames = glob_1.sync(controllersPath).map((path) => ({
        name: path_1.basename(path),
    }));
    console.group('Controller Names'.cyan.italic.bold);
    console.table(controllersNames);
    console.groupEnd();
    const app = routing_controllers_1.createExpressServer({
        controllers: [controllersPath],
        async authorizationChecker(action) {
            try {
                const token = getJWT(action.request.headers);
                if (!token)
                    throw new routing_controllers_1.UnauthorizedError();
                if (!jsonwebtoken_1.verify(token, JWT_SECRET))
                    throw new routing_controllers_1.UnauthorizedError();
                const decodedUser = decodeJWT(token);
                await typeorm_1.getConnection().getRepository(_entities_2.UsersEntity).findOne(decodedUser.id);
                return true;
            }
            catch {
                throw new routing_controllers_1.UnauthorizedError();
            }
        },
        async currentUserChecker(action) {
            try {
                const token = getJWT(action.request.headers);
                if (!token)
                    throw new routing_controllers_1.UnauthorizedError();
                const decodedUser = decodeJWT(token);
                return await typeorm_1.getConnection()
                    .getRepository(_entities_2.UsersEntity)
                    .findOne(decodedUser.id);
            }
            catch {
                throw new routing_controllers_1.UnauthorizedError();
            }
        },
    });
    app.listen(APP_PORT, () => {
        // tslint:disable-next-line: no-console
        console.log(`ðŸš€ App started on port ${APP_PORT} ðŸš€`.green.bold);
    });
    if (CONNECT_WITH_DB === 'true') {
        const con = await _entities_1.connectWithDB();
    }
    // TODO:: loop through your services and pass the db to it
    // TODO:: then each service will available through the DO we have
    // TODO:: in each controller
    // Container.set(ServiceClass, new service(con))
    routing_controllers_1.useContainer(typedi_1.Container);
};
init();
